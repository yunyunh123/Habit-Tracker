//#include "SFML/Graphics.hpp"
#include "Menu.h"
//#include "Habits.h"
#include <iostream>
#include "Textbox.h"

void newHab(Habits habit);

void makeList(std::vector<Habits> hab) {

  sf::RenderWindow window(sf::VideoMode(600, 600), "Track Habits", sf::Style::Titlebar | sf::Style::Close);
  Menu menu(window.getSize().x, window.getSize().y, hab);

  int num = hab.size();
  int index = 0;

  while (window.isOpen()) {
    sf::Event event;

    while(window.pollEvent(event)) {
      switch(event.type) {
        case sf::Event::KeyReleased: // case 1
          if(event.key.code == sf::Keyboard::Up) {
            menu.MoveUp(1);
          } else if (event.key.code == sf::Keyboard::Down) {
            menu.MoveDown(1);
          } else if (event.key.code == sf::Keyboard::Return) { 
              index = menu.GetPressedItem();
              for(int i = 0; i < num; i++) {
                if (index == i) {
                  std::cout << hab.at(i).name << std::endl;
                  newHab(hab.at(i));
                }
              }
          }
          break;
            // switch (menu.GetPressedItem()) {
            // case 0:
            //   std::cout << "Drink Water.\n";
            //   newHab(hab.at(0));
            //   break;
            // case 1: {
            //   std::cout << "Do yoga";
            //   newHab(hab.at(1));
            //   break;

      case sf::Event::Closed: // case 3
        window.close();
        break;
      }
    }
    window.clear();

    menu.drawList(window);

    window.display();
  }

}

void newHab(Habits habit) {
  sf::RenderWindow window(sf::VideoMode(600, 600), "Habit", sf::Style::Titlebar | sf::Style::Close);
  Menu menu(window.getSize().x, window.getSize().y, habit);

  int n = habit.frequency;

  /*
    make text a vector with n elements
    in menu.cpp, save the position of all the positions
    setposition for each of the elements
  */

  sf::Font arial;
  arial.loadFromFile("arial.ttf");

  std::vector<Textbox> texts;

  for (int i = 0; i < n; i++) {
    if (i == 0)
      texts.push_back(Textbox(30, sf::Color::White, true));
    else
      texts.push_back(Textbox(30, sf::Color::White, false));

    texts.at(i).setFont(arial);
    //texts.at(i).centerText();
    texts.at(i).setPosition(menu.pos.at(i + 1)); // i + 1
    texts.at(i).setLimit(true, 10);
  }

  int ind = 0;
  bool complete = false;
  while (window.isOpen()) {
    sf::Event event;

    window.pollEvent(event);
    if (event.type == sf::Event::KeyPressed) {
      if (event.key.code == sf::Keyboard::Return) {
          if (ind + 1 < n) {
            // texts.at(ind).setSelected(false);
          // else {
            texts.at(ind).setSelected(false);
            ind++;
            texts.at(ind).setSelected(true);
          } else {
            // ind++;
            // if (ind >= n) {
            //   texts.at(n-1).setSelected(false);
            //   ind = n-1;
            // }
            complete = true; // done with do yoga
            window.close();
          }
          // if (ind == n)
          //   texts.at(ind).setSelected(false);
          // else if (ind + 1 == n) {
          //   window.close();
          // }
      } 
      if (event.key.code == sf::Keyboard::Escape) {
          cout << "index: " << ind << std::endl;
          texts.at(ind).setSelected(false);
          ind = 0;
          texts.at(ind).setSelected(true);
      }
      // if (event.type == sf::Event::Closed)
      //   window.close();

    }


    while (window.pollEvent(event) and (complete == false)) {
      switch(event.type) {

      case sf::Event::TextEntered:

        texts.at(ind).typedOn(event);
        // if(event.text.unicode == 13 and ind == n)
        //   texts.at(ind).setSelected(false);
        break;
      case sf::Event::KeyPressed:
        if (event.key.code == sf::Keyboard::Return && ind + 1 == n)
          texts.at(ind).setSelected(false);
        break;
      case sf::Event::Closed:
        window.close();
      //break;
      }
    }
    window.clear();

    menu.drawList(window);

    // for (auto i : texts)
    //   i.drawTo(window); // work on this

    for (int i = 0; i < n; i++) {
      texts.at(i).drawTo(window);
    }

    window.display();

    if (complete == true) {
      break;
    }
  }

    for (int i = 0; i < n; i++) {
      cout << texts.at(i).getText() << " ";
    }

}

int main() {

  Habits hab1("Drink water", 8, "cups", 1); // move back to main
  Habits hab2("Do yoga", 15, "min", 3);
  std::vector<Habits> hab;
  hab.push_back(hab1);
  hab.push_back(hab2);

// hab1.name = "Do yoga";


  sf::RenderWindow window(sf::VideoMode(600, 600), "Habit Tracker", sf::Style::Titlebar | sf::Style::Close);
  //does not allow for resizing

  Menu menu(window.getSize().x, window.getSize().y);

  while (window.isOpen()) {
    sf::Event event;

    while(window.pollEvent(event)) {
      switch(event.type) {
      case sf::Event::KeyReleased:
        switch (event.key.code) {
        case sf::Keyboard::Up:
          menu.MoveUp(0);
          break;

        case sf::Keyboard::Down:
          menu.MoveDown(0);
          break;

        case sf::Keyboard::Return:
          switch (menu.GetPressedItem()) {
          case 0:
            std::cout << "User wants to input a new habit.\n";
            break;
          case 1: {
            makeList(hab);

            break;
          }
          case 2:
            std::cout << "User wants to view habit progress.\n";
            break;
          }

          break;
        }

        break;

      case sf::Event::Closed:
        window.close();
        break;
      }
    }

    window.clear();

    menu.drawMenu(window);

    window.display();
  }


  return 0;
}

/*things we need to generalize:
  the while loop with the switch statements
  menu.cpp
    instead of having menu and list as separate, they could just be the same thing
    but with different number of items

*/