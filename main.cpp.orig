//#include "SFML/Graphics.hpp"
#include "Menu.h"
//#include "Habits.h"
#include <iostream>
#include "Textbox.h"
#include <fstream>
#include <functional>

const int WIDTH = 600;
const int HEIGHT = 600;


void newHab(Habits habit);
void updateavg(std::string name, float todaysdata);
void makeList(std::vector<Habits> hab);
std::vector<Habits> fileinput();
//void getMenuWindow(int width, int height, std::string name, std::vector<std::string> list , bool ifnextlist, std::vector<std::function<void(void)>> nextlist, bool justChoosingHabit, std::vector<std::function<void(Habits)>> nextlist); //parameters?
void getMenuWindow(int width, int height, std::string name, std::vector<std::string> list , 
  bool ifnextlist, std::vector<std::function<void(void)>> nextlist, bool noFunction);
void getMenuWindow(int width, int height, Habits habit);


void newHabit() {


}

void userTrackHabits(Habits habit) {

  getMenuWindow(WIDTH, HEIGHT, habit);

}

void trackHabits() {
  std::vector<Habits> habit_list;
  habit_list = fileinput();

  std::vector<std::string> list;
  for (auto i : habit_list)
    list.push_back(i.name);

  std::vector<std::function<void(void)>> empty{};

  getMenuWindow(WIDTH, HEIGHT, "Track Habit(s) (press up or down key)", list, true, empty, true);

  //problem: I want to keep callign the same function but with different parameters

}

void viewProgress() {

}


void getMenuWindow(int width, int height, std::string name, std::vector<std::string> list , 
  bool ifnextlist, std::vector<std::function<void(void)>> nextlist, bool noFunction) {

  sf::RenderWindow window(sf::VideoMode(width, height), name, sf::Style::Titlebar | sf::Style::Close);
  Menu menu(width, height, list);

  int num = list.size();
  int index = 0;


    std::vector<Habits> habit_list;
  habit_list = fileinput();


  while (window.isOpen()) {
    sf::Event event;

    while(window.pollEvent(event)) {
      switch(event.type) {
      case sf::Event::KeyReleased:
        if(event.key.code == sf::Keyboard::Up) {
          menu.MoveUp();
        } else if (event.key.code == sf::Keyboard::Down) {
          menu.MoveDown();
        } else if ((event.key.code == sf::Keyboard::Return) && (ifnextlist == true)) {
          index = menu.GetPressedItem();

          if(noFunction == false){
            for(int i = 0; i < num; i++) {
              if (index == i) { // if 0 : new habit, if 1: track habit, if 2: view habit
                // std::string nextName = list.at(i) + " (press up or down key)";
                // getMenuWindow(width, height, nextName, nextlist, false, {""});
                nextlist.at(i)();
              }
            }
          } else {
            userTrackHabits(habit_list.at(index));
          }
        }
        break;
      case sf::Event::Closed:
        window.close();
        break;
      }
    }

    menu.drawMenu(window);
    window.display();

  }
}
//with text input
void getMenuWindow(int width, int height, Habits habit) {
  std::string name = habit.name + " (insert directions)";
  sf::RenderWindow window(sf::VideoMode(width, height), name, sf::Style::Titlebar | sf::Style::Close);
  
  // Creating the list
  std::vector<std::string> list;
  int num_freq = habit.frequency;
  int num_list = num_freq + 1;
  list.resize(num_list);

  list.at(0) = habit.name + " (" + std::to_string(habit.amount) + " " + habit.units + "/day)";
  for (int i = 1; i <= num_freq; i++) {
    list.at(i) = std::to_string(i) + ". ________" + habit.units;
  }

  Menu menu(WIDTH, HEIGHT, list);

  // Setting up textboxes 
  sf::Font arial;
  arial.loadFromFile("arial.ttf");
  std::vector<Textbox> texts;
  sf::Vector2f center(-50.f, -30.f); // to center the textbox

  for (int i = 0; i < num_freq; i++) {
    if (i == 0)
      texts.push_back(Textbox(30, sf::Color::White, true));
    else
      texts.push_back(Textbox(30, sf::Color::White, false));

    texts.at(i).setFont(arial);

    texts.at(i).setPosition(menu.pos.at(i + 1) + center);
    texts.at(i).setLimit(true, 5);
  }

  int ind = 0;
  while (window.isOpen()) {
    sf::Event event;

    window.pollEvent(event);

    if (event.type == sf::Event::KeyPressed) {
      if (event.key.code == sf::Keyboard::Return) {
        if (ind + 1 < num_freq) {
          texts.at(ind).setSelected(false);
          ind++;
          texts.at(ind).setSelected(true);
        }
      }
      if (event.key.code == sf::Keyboard::Escape) {
        texts.at(ind).setSelected(false);
        ind = 0;
        texts.at(ind).setSelected(true);
      }
    }

    while (window.pollEvent(event)) {
      if (event.type == sf::Event::TextEntered) {
        texts.at(ind).typedOn(event);
      }
    }


    if (event.type == sf::Event::Closed) {
      window.close();
    }


    window.clear();
    menu.drawMenu(window);

    for (int i = 0; i < num_freq; i++) {
      texts.at(i).drawTo(window);
    }

    window.display();
  }

  float runsum = 0;
  for (int i = 0; i < num_freq; i++) {
    try {
      runsum += std::stof(texts.at(i).getText());
    } catch(const std::invalid_argument& ia) {
      std::cerr << "Invalid arguments. Please enter numbers.\n";
      userTrackHabits(habit);
    }
  }

}


int main() {

  std::vector<Habits> hab;
  hab = fileinput();
// hab1.name = "Do yoga";
  std::vector<std::string> list = {"New Habit", "Track Habit(s)", "View Habit Progress"};

  std::vector<std::string> list2;
  for (auto i : hab)
    list2.push_back(i.name);


  std::vector<std::function<void(void)>> functions{newHabit, trackHabits, viewProgress};


  getMenuWindow(WIDTH, HEIGHT, "Menu (press up or down key)", list, true, functions, false); // make 600 into constants WIDTH and HEIGHT



  return 0;
}


std::vector<Habits> fileinput() {
  std::ifstream thisfile;

  std::vector<Habits> hab;
  Habits temp;
  int counter = 1;

  thisfile.open("currenthabs.txt");
  std::string word;
  while (thisfile >> word) {
    if (counter == 1) {
      while (word.find('_', 1) != std::string::npos)
        word.replace(word.find('_', 1), 1, " ");
      temp.name = word;
    } else if (counter == 2)
      temp.amount = std::stof(word);
    else if (counter == 3)
      temp.units = word;
    else if (counter == 4)
      temp.frequency = std::stoi(word);
    else if (counter == 5) {
      temp.isDone = (word == "true");
      hab.push_back(temp);
      counter = 0;
    } // add another data point for daily average + today's amount?
    counter++;
  }

  // for (int i = 0; i < hab.size(); i++) {
  //   std::cout << hab.at(i).name << " " << hab.at(i).amount << " " << hab.at(i).units
  //             << " " << hab.at(i).frequency << " " << hab.at(i).isDone << "\n";
  // }

  thisfile.close();

  return hab;
}


void updateavg(std::string name, float todaysdata) {

  std::ifstream avgdata;

  avgdata.open("avgdata.txt");
  std::string word;
  int count = 1;
  std::string tempname;
  bool isHabit = false;
  float currentavg, newavg;
  int daysentered;

  while (avgdata >> word) {
    if (count == 1) {
      while (word.find('_', 1) != std::string::npos)
        word.replace(word.find('_', 1), 1, " ");
      tempname = word;
      if (tempname == name)
        isHabit = true;
    } else if (count == 2 && isHabit)
      currentavg = std::stof(word);
    else if (count == 3 && isHabit) {
      daysentered = std::stoi(word);
      break;
    }
    if (count == 3)
      count = 0;
    count++;
  }

  avgdata.close();

  newavg = (currentavg * daysentered + todaysdata) / (daysentered + 1);
  daysentered++;

  avgdata.open("avgdata.txt");
  std::string theline;
  std::vector<string> updatedfile;

  while (std::getline(avgdata, theline))
    updatedfile.push_back(theline);

  for (int i = 0; i < name.length(); i++) {
    if (name.at(i) == ' ')
      name.at(i) = '_';
  }

  for (int i = 0; i < updatedfile.size(); i++) {
    if (updatedfile.at(i).find(name) != std::string::npos) {
      updatedfile.at(i) = name + " " + std::to_string(newavg)
                          + " " + std::to_string(daysentered);
    }
  }

  avgdata.close();

  std::ofstream newdata;
  newdata.open("avgdata.txt", std::fstream::trunc);

  for (string s : updatedfile)
    newdata << s << "\n";

  newdata.close();
}

